{"type":"getPostByPath","data":{"title":"Lua原生函数load的继承性","date":"2022-11-19T00:00:00.000Z","description":"","categories":[{"name":"技术","_id":"clcqwjx4y000de6on5fxyd5y9"},{"name":"Lua","_id":"clcqwjx5l0018e6onhaf24bp4"}],"tags":[{"name":"教程","_id":"clcqwjx53000je6on83c1fr06"}],"content":"<h2 id=\"Lua原生函数load的继承性\"><a href=\"#Lua原生函数load的继承性\" class=\"headerlink\" title=\"Lua原生函数load的继承性\"></a><strong>Lua原生函数load的继承性</strong></h2><p>这篇帖子是没有学习目标的，并且更适合有<strong>Lua编写基础</strong>的人观看。<br><del>今天就是想不明不白的开始。</del><br>关于 <code>load</code>，如果看过<span class=\"exturl\" data-url=\"aHR0cHM6Ly9mb3J1bS5rb2tvbmEudGVjaC9kLzEzODY=\">【指令脚本/抛砖引玉】Load: 在聊天窗口使用lua<i class=\"fa fa-external-link-alt\"></i></span> 那么你或许会对它熟悉一些，此函数是 <code>lua 5.1</code>就有的东西，作用是加载一个数据块。下面是现今的<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubHVhLm9yZy9tYW51YWwvNS4yL21hbnVhbC5odG1sI3BkZi1sb2Fk\">官方5.2 manual<i class=\"fa fa-external-link-alt\"></i></span>给出的关于它的介绍：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">load (ld [, source [, mode [, env]]])</span><br><span class=\"line\">Loads a chunk.</span><br><span class=\"line\"></span><br><span class=\"line\">If is a string, the chunk is this string. If is a function, calls it repeatedly to get the chunk pieces. Each call to must return a string that concatenates with previous results. A return of an empty string, nil, or no value signals the end of the chunk. ldldloadld</span><br><span class=\"line\"></span><br><span class=\"line\">If there are no syntactic errors, returns the compiled chunk as a function; otherwise, returns nil plus the error message.</span><br><span class=\"line\"></span><br><span class=\"line\">If the resulting function has upvalues, the first upvalue is set to the value of , if that parameter is given, or to the value of the global environment. (When you load a main chunk, the resulting function will always have exactly one upvalue, the variable (see §2.2). When you load a binary chunk created from a function (see string.dump), the resulting function can have arbitrary upvalues.) env_ENV</span><br><span class=\"line\"></span><br><span class=\"line\">source is used as the source of the chunk for error messages and debug information (see §4.9). When absent, it defaults to , if is a string, or to &quot;&quot; otherwise. ldld&#x3D;(load)</span><br><span class=\"line\"></span><br><span class=\"line\">The string controls whether the chunk can be text or binary (that is, a precompiled chunk). It may be the string &quot;&quot; (only binary chunks), &quot;&quot; (only text chunks), or &quot;&quot; (both binary and text). The default is &quot;&quot;.modebtbtbt</span><br></pre></td></tr></table></figure>\n\n<blockquote>\n<p>什么意思？</p>\n</blockquote>\n<p>坦白来说，<strong>就是从字符串或者函数中加载一个代码块为方法并返回。</strong>——应该不难理解吧？</p>\n<p>但你需要明白以下几点：</p>\n<ol>\n<li><code>load()</code>返回的是函数,需要调用的话,还需要加括号。</li>\n<li>5.1.x版本 <code>load</code>方法为 <code>load(func[,chunkname])</code>从函数中加载，<code>loadstring(str[,chunkname])</code>从字符串中加载</li>\n<li>5.3.x版本为 <code>load (chunk [, chunkname [, mode [, env]]])</code><br><code>chunk</code>为函数或字符串<br><code>mode</code>为加载模式:”t”文本样式,”b”二进制样式,”bt”二进制和文本模式.<br><code>env</code>代码块需要的参数</li>\n</ol>\n<p>你可以这样对自己的骰娘做个测试<del>（我称此方法为简式测试法）</del>：</p>\n<ol>\n<li>在 <code>DiceQQ\\plugin\\</code>下新建 <code>test.lua</code>。</li>\n<li>在 <code>DiceQQ\\plugin\\test.lua</code>内写上如下代码：</li>\n</ol>\n<figure class=\"highlight lua\"><figcaption><span>test.lua</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">msg_order=&#123;[<span class=\"string\">&quot;@&quot;</span>]=<span class=\"string\">&quot;main&quot;</span>&#125;</span><br><span class=\"line\"><span class=\"keyword\">local</span> main = <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(msg)</span></span> <span class=\"keyword\">return</span> <span class=\"built_in\">load</span>(msg.fromMsg:<span class=\"built_in\">sub</span>(<span class=\"number\">2</span>))() <span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>对骰娘发送 <code>.system load</code>命令重载。</li>\n<li>对骰娘发送 <code>@return msg.fromQQ</code>，你将会收到自己的QQ。</li>\n</ol>\n<p>其实到这里就是<span class=\"exturl\" data-url=\"aHR0cHM6Ly9mb3J1bS5rb2tvbmEudGVjaC9kLzEzODY=\">【指令脚本/抛砖引玉】Load: 在聊天窗口使用lua<i class=\"fa fa-external-link-alt\"></i></span> 的全部内容了。下面进入正题。<br>因为昨天，哦不，今天凌晨喝的有点多，又很奇怪的是我醒的特别早，我大概五点就醒了，然后开始敲代码，也许是酒精的作用吧，我对krypton进行了如下无厘头测试：</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tbl=&#123;&#125;</span><br><span class=\"line\">tbl[<span class=\"string\">&#x27;第1层&#x27;</span>]=<span class=\"string\">&quot;tbl[\\&quot;tbl[&#x27;第2层&#x27;]\\&quot;]&quot;</span></span><br><span class=\"line\">tbl[<span class=\"string\">&quot;tbl[&#x27;第2层&#x27;]&quot;</span>]=<span class=\"string\">&quot;第3层&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"built_in\">load</span>(<span class=\"string\">&quot;return &quot;</span>..tbl[<span class=\"string\">&#x27;第1层&#x27;</span>])()</span><br></pre></td></tr></table></figure>\n\n<p>猜猜返回了什么？</p>\n<p>我又进行了推导：</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tbl=&#123;&#125;</span><br><span class=\"line\">tbl[<span class=\"string\">&#x27;第1层&#x27;</span>]=<span class=\"string\">&quot;tbl[\\&quot;tbl[&#x27;第2层&#x27;]\\&quot;]&quot;</span></span><br><span class=\"line\">tbl[<span class=\"string\">&quot;tbl[&#x27;第2层&#x27;]&quot;</span>]=<span class=\"string\">&quot;tbl[\\&quot;tbl[&#x27;第3层&#x27;]\\&quot;]&quot;</span></span><br><span class=\"line\">tbl[<span class=\"string\">&quot;tbl[\\&quot;tbl[&#x27;第3层&#x27;]\\&quot;]&quot;</span>]=<span class=\"string\">&quot;第4层&quot;</span></span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"built_in\">load</span>(<span class=\"string\">&quot;return &quot;</span>..tbl[<span class=\"string\">&#x27;第1层&#x27;</span>])()</span><br></pre></td></tr></table></figure>\n\n<p>又返回了什么？<br>希望能有人好好运用吧。<del>再不行就只能我自己写了()</del></p>\n<center><b>教程结束。</b></center>\n","_path":"2022/11/19/Lua原生函数load的继承/","_link":"https://jyunko.cn/2022/11/19/Lua%E5%8E%9F%E7%94%9F%E5%87%BD%E6%95%B0load%E7%9A%84%E7%BB%A7%E6%89%BF/","_id":"clcqwjx4r0006e6on2kce1myz"}}